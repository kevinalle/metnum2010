\documentclass[12pt,titlepage]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caratulaMetNum}
\usepackage{float}
\usepackage{subfigure}
\usepackage{listings}
\lstset{language=C,basicstyle=\small\tt,keywordstyle=\bf,tabsize=3,breaklines=true,linewidth=16cm,postbreak={\mbox{$\rightsquigarrow$}},prebreak={\mbox{$\rightsquigarrow$}}}

 \usepackage{a4wide}
% \usepackage{amssymb}
% \usepackage{amsmath}
 \usepackage{enumerate}
% \usepackage[utf8]{inputenc}
% \usepackage[spanish]{babel}
% \parindent = 0 pt
 \parskip = 11 pt
% \usepackage[width=15.5cm, left=3cm, top=2.5cm, height= 24.5cm]{geometry}

\usepackage{color}
\usepackage{url}
\definecolor{lnk}{rgb}{0,0,0.4}
\usepackage[colorlinks=true,linkcolor=lnk,citecolor=blue,urlcolor=blue]{hyperref}

\newcommand{\func}[2]{\texttt{#1}(#2) :}
\newcommand{\tab}{\hspace*{2em}}
\newcommand{\FOR}{\textbf{for }}
\newcommand{\TO}{\textbf{ to }}
\newcommand{\IF}{\textbf{if }}
\newcommand{\WHILE}{\textbf{while }}
\newcommand{\THEN}{\textbf{then }}
\newcommand{\ELSE}{\textbf{else }}
\newcommand{\RET}{\textbf{return }}
\newcommand{\MOD}{\textbf{ \% }}
\newcommand{\OR}{\textbf{ or }}
\newcommand{\NOT}{\textbf{ not }}
\newcommand{\tOde}[1]{\tab \small{\mathcal{O}($#1$)}}
\newcommand{\Ode}[1]{\ensuremath{\small{\mathcal{O}\left(#1\right)}}}
\newcommand{\VSP}{\vspace*{3em}}
\newcommand{\Pa}{\vspace{5mm}}
\newenvironment{pseudo}{\noindent\begin{tabular}{ll}}{\end{tabular}\VSP}

\newenvironment{while}{\WHILE \\ \setlength{\leftmargin}{0em} }{}

\newcommand{\iif}{\Leftrightarrow}
\newcommand{\gra}[1]{\noindent\includegraphics[scale=.70]{#1}\\}
\newcommand{\gras}[2]{\noindent\includegraphics[scale=#2]{#1}\\}
\newcommand{\gram}[1]{\noindent\includegraphics[scale=.50]{#1}}
\newcommand{\dirmail}[1]{\normalsize{\texttt{#1}}}
\newenvironment{usection}[1]{\newpage\begin{section}*{#1}	\addcontentsline{toc}{section}{#1}}{\end{section}}
\newenvironment{usubsection}[1]{\begin{subsection}*{#1}	\addcontentsline{toc}{subsection}{#1}}{\end{subsection}}

\newcommand{\superref}[1]{\textsuperscript{\ref{#1}}}

%\title{{\sc\normalsize Métodos Numéricos}\\{\bf Trabajo Práctico Nº1}}
%\author{\begin{tabular}{lcr}Pablo Herrero & LU & \dirmail{pablodherrero@gmail.com}\\Thomas Fischer & 489/08 & \dirmail{tfischer@dc.uba.ar}\\Kevin Allekotte & 490/08 & \dirmail{kevinalle@gmail.com} \end{tabular}}
%\date{\VSP \normalsize{Abril 2010}}
\begin{document}

\materia{Métodos Numéricos}
\titulo{Trabajo Práctico Nº1}
\subtitulo{``Perdidos'' en el Pacífico}
%\grupo{Grupo x}
\integrante{Pablo Herrero}{332/07}{pablodherrero@gmail.com}
\integrante{Thomas Fischer}{489/08}{tfischer@dc.uba.ar}
\integrante{Kevin Allekotte}{490/08}{kevinalle@gmail.com}

\abstracto{
	El siguiente trabajo se propone la comparación entre distintos
	métodos de simulación analítica de sistemas gravitatorios
	de varios cuerpos. El objetivo final es calcular las coordenadas
	para tirar un proyectil el 12 de junio del año 2010 a las 11:00hs,
	UTC-3 desde la órbita del planeta Neptuno para que el mismo impacte
	en la Tierra.
}

\palabraClave{}

\begin{titlepage}
\maketitle
\end{titlepage}
\tableofcontents
\newpage

	\begin{usection}{Introducción teorica}

		En la mecánica classica o Newtoniana, el problema de lo $n$
		cuerpos es el problema de predecir el movimiento de cuerpos
		celestes en mutua interacción gravitatoria para cualquier
		instante en el futuro o deducir su movimiento en cualquier
		instante del pasado.

		La acción gravitatoria entre los cuerpos depende de las
		posiciones relativas entre ellos, por lo que las ecuaciones de
		interacción gravitatoria quedan definidas en términos de
		ecuaciones diferenciales.

		El problema que surge al plantear el problema con $3 \leq n$ es
		que las ecuaciones el sistema quedan definidas en función de
		demasiadas variables como para aplicar los métodos de integración
		conocidos hoy en día para resolver las ecuaciones.

		Luego tenemos que encontrar otra forma de calcular las
		variables. En nuestro caso elegimos el método de simulación,
		el cuál introduce errores analíticos por discretizar el tiempo y
		de redondeo por trabajar con la aritmética finita de la
		computadora, pero que tiene la ventaja que el sistema a resolver
		es lineal, para lo cuál conocemos un método.

		Para minimizar estos errores implementamos distintos métodos de
		cálculo numérico de aproximación que validamos con sistemas
		familiares como el sistema solar, del cual sabemos por ejemplo
		que las órbitas son elípticas y bastante estables. Si dibujamos
		las órbitas simuladas podemos ver si se comportan de manera
		similar a lo esperado. Además, tenemos datos que se supone son
		bastante precisos descargados de la web oficial de la NASA para
		comparar.

	\end{usection}

	\begin{usection}{Desarrollo}

		En primer lugar el desarrollo consistio en implementar módulos
		para las operaciones con y entre Matrices y Vectores que
		fuesen necesarios para resolver sistemas lineales. Esto
		implicaba también implementar el algoritmo de eliminación
		Gaussiana con pivoteo parcial para resolver el sistema lineal
		del segundo método de resolución. Los módulos fueron
		implementados en el lenguaje \texttt{C++} para garantizar una
		buena performance.

		Luego procedimos a implementar un entorno de simulación
		(\texttt{C++}) y un pequeño script para plotear y poder
		visualizar los resultados (\texttt{Python}). 

		Con todo el backend funcionando, procedimos a implementar
		gradualmente los distintos algoritmos de solución de sistemas
		lineales, intercalando la producción de cada uno, con fases de
		validación que consistían en simular los sistemas propuestos
		en el enunciado, y cuyos resultados se pueden observar en la
		sección \textbf{resultados} \ref{sec:res}.

		Validados los métodos de simulación, tuvimos que idear un
		algoritmo para calcular el vector de velocidad inicial de
		nuestro misil dirigido a la tierra, de tal manera que le pegase.
		La idea fue hacer una especie de búsqueda local, ya que
		suponíamos que de no colisionar con otro planeta en la
		trayectoria hasta la tierra, si pasabamos con una trayectoría
		mas cerca de la tierra que con otra, podíamos reducir la
		búsqueda de la solución a un espacio localizado cerca de la
		primera. Con un espacio o una trayectoria nos referimos a una
		velocidad inicial, la que en nuestro código esta determinada por
		dos ángulos de disparo. Uno alrededor el eje $\hat{z}$, sobre el
		plano $\hat{x}\hat{y}$ ($\phi$) y otro alrededor del eje $\hat{y}$, sobre
		el plano $\hat{x}\hat{z}$ ($\theta$).
		
		Dadas las condiciones iniciales de un sistema (posiciones y velocidades de todos los cuerpos), podemos simular este sistema con alguno de los métodos y calcular las posiciones para algun tiempo en el futuro.
		Nuestro objetivo es encontrar la velocidad inicial de nuestro misil para que esté a menos de $10^{-4}$ AU de la tierra en algun instante futuro.
		Definimos entonces una función (\texttt{mindist}) que dadas las condiciones iniciales, un cuerpo \texttt{misil} y un cuerpo \texttt{target}, nos devuelva la distancia mínima a la que se encontrarán estos cuerpos en algun futuro acotado.
		Nos restringimos a los casos en los que la distancia es monótonamente decreciente, y consideramos sólo los tiempos para los cuales los cuerpos se acercan. (Esto es una desicion de implementación, ya que no estaríamos encontrando las soluciones en las que el misil se aleja y luego se vuelve a acercar).
		
		Tenemos entonces que minimizar esta función (o encontrar un valor para el cual sea menor que $10^{-4}$).
		Para esto elegimos una velocidad inicial a mano (aproximadamente hacia el cuerpo \texttt{target}) y corremos un algoritmo que va ajustando la velocidad para minimizar la función \texttt{mindist}. [Más detalles en \textbf{Discusión}]

		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.6]{mindist3.png}
			\caption{Esta es la forma de la función \texttt{mindist} para ciertas condiciones iniciales, donde el dominio es $\phi\times\theta$ (la velocidad inicial del proyectil) y la imagen es la distancia mínima.}
			\label{fig:mindist}
		\end{figure}	

	\end{usection}

	\begin{usection}{Resultados}
	\label{sec:res}

		\input{resultados_ej1_m1.tex}
		\input{resultados_ej1_m2.tex}
		\input{resultados_ej1_m3.tex}
		\input{resultados_ej2_m1.tex}
		\input{resultados_ej2_m2.tex}
		\input{resultados_misil.tex}
		\input{resultados_bomba.tex}

	\end{usection}
	
	\begin{usection}{Discusión}
		
		
		\begin{usubsection}{Algoritmo de búsqueda del mínimo \texttt{mindist}}
		Para cada trayectoria inicial, definimos una grilla de $3 \times 3$
		puntos, donde el punto central era ella misma, y los otros
		puntos son las rotaciones de la velocidad sobre los ejes
		anteriormente mencionados por dos ángulos, respectivamente, de
		un módulo inicial que se reduce a la mitad en cada iteración de
		la búsqueda, y luego disparámos misiles en todas las 9
		direcciónes.
		Así, aunque en algunos casos asintóticamente,
		podemos llegar a cualquier punto del espacio
		contenido en la grilla inicial (la definida en la primera
		iteración) si alli se encuentra una solución.
		A la grilla inicial le ponemos un ancho inicial grosero, de
		manera de incluír casi necesariamente a alguna solución.

		En la imágen a continuación se puede ver como evoluciona la grilla
		de la búsqueda a medida queavanza el algoritmo.

		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.5]{img/grid.png}
			\caption{
				En la imagen vemos una representación gráfica de los
				sucesivos espacios de búsqueda local. el orden de las
				iteraciones es rojo $\rightarrow$ azul
				$\rightarrow$ verde.
			}
			\label{fig:grilla}
		\end{figure}		

		Para elegir la trayectoria inicial del algoritmo, calculamos
		primero aproximadamente (simulando y visualizando) cuanto
		tiempo tardaba el misil en llegar hasta la órbita terrestre
		desde la órbita de neptuno. Luego calculamos aproximadamente
		la posición de la Tierra en esa cantidad de tiempo después de la
		fecha inicial de lanzamiento, tomando los datos de la posición
		de ese día de la información que provee la NASA.

		También de esos datos, elegimos un punto aproximado en la
		órbita de Neptuno de manera que el misil se encontrase de frente
		o desde atrás con la dirección de la órbita terrestre, ya que si
		se encontrase de costado con ésta, sería mucho mas dificil
		pegarle por estar en movimiento.

		Como dirección de la velocidad inicial del misil, elegimos el
		vector resultante de restar la posición inicial del misil a la
		posición aproximada del impacto sobre la órbita terrestre.
		El módulo de la velocidad inicial, es el propuesto por el
		enunciado del problema.

		Luego de probar para un par de posiciones y velocidades
		iniciales distintas, encontramos soluciones donde pudimos
		destruír la tierra. Las mismas están detalladas en la sección
		siguiente.
		\end{usubsection}

		
	\end{usection}
	
	\begin{usection}{Conclusiones}

		Llegamos a la conclusión que, dados los métodos implementados,
		el mejor en la práctica para el ejercicio de destruír la tierra, resulto ser el método 1, ya que,
		los otros solo resultaban muy buenos (mejores incluso en cuanto a los resultados finales que el método 1)
		si el $\Delta t$ era significativamente muy alto,
		lo que para nuestro algoritmo de búsqueda local era muy malo en cuanto a tiempo de ejecución.

	\end{usection}
	
	\begin{usection}{Apéndices}
		\begin{usubsection}{Apéndice A: Enunciado}
			\input{enunciado.tex}
		\end{usubsection}
		
		\newpage
		\begin{usubsection}{Apéndice B: Codigos Fuente}

\textbf{Algunos defines}
\begin{lstlisting}
#define G 0.000148818071108351462554986428198016585385
#define F(i,j,x) (-G*Cuerpos[i].m*Cuerpos[j].m*(y[3*N+3*i+x]-y[3*N+3*j+x])/(dist*dist*dist))
#define AC(i,j,x) (-G*Cuerpos[j].m*(y[3*N+3*i+x]-y[3*N+3*j+x])/(dist*dist*dist))
#define yX(i) y[3*N+3*(i)]
#define yY(i) y[3*N+3*(i)+1]
#define yZ(i) y[3*N+3*(i)+2]
#define XYZ(i) V3(yX(i),yY(i),yZ(i))
#define VEL(i) V3(y[3*(i)],y[3*(i)+1],y[3*(i)+2])
#define sq(x) ((x)*(x))
\end{lstlisting}

\bigskip
\textbf{Extracto de \texttt{main}, que minimiza \texttt{mindist}}
\begin{lstlisting}
int intento=0;
while(min.first>1e-4 && intento<26){
	intento++;
	for(int ii=-1;ii<=1;ii++) for(int jj=-1;jj<=1;jj++){
		Cuerpos[misil_index].v = pdir.rotate(ii*span,jj*span); // Calculo direccion
		y=makeY(); // Rehago el vector y
		pair<long double,int> new_min = mindist(y,misil_index,target_index);
		if( new_min.first<min.first || ( new_min.first==min.first && new_min.second<min.second ) ){
			min = new_min;
			mindir = Cuerpos[misil_index].v;
		}
	}

	pdir=mindir;
	span*=.6;
	clog << "mindist: " << min.first << " span: " << span << " dir: " << pdir << " it: " << min.second << endl;
}
\end{lstlisting}

\bigskip
\textbf{Función \texttt{mindist}}
\begin{lstlisting}
pair<long double,int> mindist(const Vn& y_in, int obj, int target){
	/* Calcula la minima distancia a la que le pasa el proyectil a la tierra */
	// Devuelve la distancia minima que alcanzan los objetos obj y target mientras se esten acercando y mientras no supere el tiempo de simulacion
	double dtbak=dt;
	Vn y(y_in);
	long double d=(XYZ(obj)-XYZ(target)).norm();
	long double dans;
	int i=0;
	do{
		dans=d;
		y=next(y);
		d=(XYZ(obj)-XYZ(target)).norm();
		if(VEL(obj).norm()*dt>d*.005){ dt*=.5; /*clog << "dt: " << dt << endl;*/}
	}while(d<dans && ++i<resolution);
	dt=dtbak;
	return pair<long double,int>(dans,i);
}
\end{lstlisting}

\bigskip
\textbf{Funciones que calculan la matriz Df}
\begin{lstlisting}
Matriz dFdx(int i, int j, const Vn& y){
	long double d=sqrt( sq(yX(i)-yX(j)) + sq(yY(i)-yY(j)) + sq(yZ(i)-yZ(j)) );
	long double d3=1/(d*d*d);
	long double d5=3/(d*d*d*d*d);
	long double dx=yX(i)-yX(j);
	long double dy=yY(i)-yY(j);
	long double dz=yZ(i)-yZ(j);
	Matriz dFdx(3,3,0);
	dFdx(0,0)=d3-d5*dx*dx; dFdx(0,1) = -d5*dx*dy; dFdx(0,2) = -d5*dx*dz;
	dFdx(1,0) = -d5*dx*dy; dFdx(1,1)=d3-d5*dy*dy; dFdx(1,2) = -d5*dy*dz;
	dFdx(2,0) = -d5*dx*dz; dFdx(2,1) = -d5*dy*dz; dFdx(2,2)=d3-d5*dz*dz;
	return -G*Cuerpos[i].m*Cuerpos[j].m*dFdx;
}

Matriz Df(const Vn& y){
	Matriz res(6*N,6*N,0);
	// lleno A21
	forn(i,3*N) forn(j,3*N) if(i==j) res(3*N+i,j) = 1;
	// lleno A12
	forn(i,N) forn(j,N) {
		Matriz S(3,3,0);
		if(i==j){
			forn(k,N) if(k!=i) S += dFdx(i,k,y);
			S *= (1./Cuerpos[i].m);
		}else{
			S = (1./Cuerpos[i].m)*dFdx(i,j,y);
		}
		forn(ii,3) forn(jj,3) res(3*i+ii,3*N+3*j+jj) = (long double)S(ii,jj);
	}
	return res;
}
\end{lstlisting}

\bigskip
\textbf{Funcion f(y) ($\frac{\delta y}{\delta t}$)}
\begin{lstlisting}
Vn f(const Vn& y){
	Vn res(6*N,0);
	forn(i,N){
		long double sumx=0,sumy=0,sumz=0;
		forn(j,N) if(j!=i){
			long double dist=(V3(y[3*N+3*i],y[3*N+3*i+1],y[3*N+3*i+2])-V3(y[3*N+3*j],y[3*N+3*j+1],y[3*N+3*j+2])).norm();
			sumx+=AC(i,j,0);
			sumy+=AC(i,j,1);
			sumz+=AC(i,j,2);
		}
		res[3*i]  =sumx;
		res[3*i+1]=sumy;
		res[3*i+2]=sumz;
	}
	forn(i,3*N) res[i+3*N]=y[i];
	return res;
}
\end{lstlisting}

\bigskip
\textbf{Método 2 (Taylor)}
\begin{lstlisting}
Matriz Taylor(const Vn& y){
	Matriz Dfy = Df(y);
	Matriz A( Matriz::ID(6*N) - dt*Dfy );
	return A.resolver( y + dt*( f(y) - Dfy*y ) );
}
\end{lstlisting}

\bigskip
\textbf{Método 3 (Iterativo)}
\begin{lstlisting}
Vn MetodoIterativo(const Vn& y, const long double dx){
	Vn w0(y); Vn w1(y);
	long double d0 = INF; long double d1 = INF;
	int i=0;
	do{
		w0 = w1;
		Matriz Dfw = Df(w0);
		Matriz A( Matriz::ID(6*N) - dt*Dfw );
		Matriz B( y + dt*( f(w0) - Dfw*w0 ) );
		w1 = A.resolver( B );

		d0 = d1;
		d1 = dist(w1-w0);
		i++;
	}while( d1<d0 && d1<dx );
	return w0;
}
\end{lstlisting}

\bigskip
\textbf{Resolucion de sistemas lineales (Gauss)}
\begin{lstlisting}
Matriz Matriz::resolver(const Vector& b){
	double U2[n*m]; forn(i,n*m) U2[i] = M[i];
	int P2[n]; forn(i,n) P2[i] = i;

	//double res[n]; forn(i,n) res[i] = b.elem(i,0);
	Vector res(b);

	forn(k,n-1) triangular(res,U2,P2,k);

	fornr(i,n){
		forsn(j,i+1,n) res[i] -= U2[i*m + j]*res[j];
		res[i] /= U2[i*m + i];
	}
	return res;
}

void Matriz::triangular(Vector& res, double* U2, int* P2, const int k){
	int f = k;
	double p = U2[f*m + k];

	// elijo la fila pivote donde el k-esimo elem es maximo
	forsn(i,k,n) if( abs(U2[i*m + k]) > abs(p) ){ f = i; p = U2[f*m + k]; }

	// swapeo las filas f y k en U y res
	forn(j,n){
		double temp_U2 = U2[f*m + j];
		U2[f*m + j] = U2[k*m + j];
		U2[k*m + j] = temp_U2;
		double temp_r = res[f];
		res[f] = res[k];
		res[k] = temp_r;
	}

	// actualizo el vector de perumtacion
	int temp = P2[f];
	P2[f] = P2[k];
	P2[k] = temp;

	// triangulo las filas k+1 -> n
	forsn(i,k+1,n){
		// elijo el m_ij
		double a = U2[i*m+k]/p;
		// la k-esima columna es 0
		U2[i*m+k] = 0;
		// calculo el valor de las columnas k+1 -> n
		forsn(j,k+1,n) U2[i*m+j] -= a*U2[k*m+j];
		res[i] -= a*res[k];
	}
}
\end{lstlisting}

		\end{usubsection}
	\end{usection}
	
	\begin{usection}{Referencias}

	\begin{enumerate}
		\item \label{ref:label} \texttt{http://url} \\ Descripcion
	\end{enumerate}	
	
	\end{usection}

\end{document}

