\documentclass[12pt,titlepage]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{caratulaMetNum}
\usepackage{float}
\usepackage{subfigure}

 \usepackage{a4wide}
% \usepackage{amssymb}
% \usepackage{amsmath}
 \usepackage{enumerate}
% \usepackage[utf8]{inputenc}
% \usepackage[spanish]{babel}
 \parindent = 0 pt
 \parskip = 11 pt
% \usepackage[width=15.5cm, left=3cm, top=2.5cm, height= 24.5cm]{geometry}

\usepackage{color}
\usepackage{url}
\definecolor{lnk}{rgb}{0,0,0.4}
\usepackage[colorlinks=true,linkcolor=lnk,citecolor=blue,urlcolor=blue]{hyperref}

\newcommand{\func}[2]{\texttt{#1}(#2) :}
\newcommand{\tab}{\hspace*{2em}}
\newcommand{\FOR}{\textbf{for }}
\newcommand{\TO}{\textbf{ to }}
\newcommand{\IF}{\textbf{if }}
\newcommand{\WHILE}{\textbf{while }}
\newcommand{\THEN}{\textbf{then }}
\newcommand{\ELSE}{\textbf{else }}
\newcommand{\RET}{\textbf{return }}
\newcommand{\MOD}{\textbf{ \% }}
\newcommand{\OR}{\textbf{ or }}
\newcommand{\NOT}{\textbf{ not }}
\newcommand{\tOde}[1]{\tab \small{\mathcal{O}($#1$)}}
\newcommand{\Ode}[1]{\ensuremath{\small{\mathcal{O}\left(#1\right)}}}
\newcommand{\VSP}{\vspace*{3em}}
\newcommand{\Pa}{\vspace{5mm}}
\newenvironment{pseudo}{\noindent\begin{tabular}{ll}}{\end{tabular}\VSP}

\newenvironment{while}{\WHILE \\ \setlength{\leftmargin}{0em} }{}

\newcommand{\iif}{\Leftrightarrow}
\newcommand{\gra}[1]{\noindent\includegraphics[scale=.70]{#1}\\}
\newcommand{\gras}[2]{\noindent\includegraphics[scale=#2]{#1}\\}
\newcommand{\gram}[1]{\noindent\includegraphics[scale=.50]{#1}}
\newcommand{\dirmail}[1]{\normalsize{\texttt{#1}}}
\newenvironment{usection}[1]{\newpage\begin{section}*{#1}	\addcontentsline{toc}{section}{#1}}{\end{section}}
\newenvironment{usubsection}[1]{\begin{subsection}*{#1}	\addcontentsline{toc}{subsection}{#1}}{\end{subsection}}

\newcommand{\superref}[1]{\textsuperscript{\ref{#1}}}

%\title{{\sc\normalsize Métodos Numéricos}\\{\bf Trabajo Práctico Nº1}}
%\author{\begin{tabular}{lcr}Pablo Herrero & LU & \dirmail{pablodherrero@gmail.com}\\Thomas Fischer & 489/08 & \dirmail{tfischer@dc.uba.ar}\\Kevin Allekotte & 490/08 & \dirmail{kevinalle@gmail.com} \end{tabular}}
%\date{\VSP \normalsize{Abril 2010}}
\begin{document}

\materia{Métodos Numéricos}
\titulo{Trabajo Práctico Nº1}
\subtitulo{``Perdidos'' en el Pacífico}
%\grupo{Grupo x}
\integrante{Pablo Herrero}{332/07}{pablodherrero@gmail.com}
\integrante{Thomas Fischer}{489/08}{tfischer@dc.uba.ar}
\integrante{Kevin Allekotte}{490/08}{kevinalle@gmail.com}

\abstracto{
	El siguiente trabajo se propone la comparación entre distintos
	métodos de simulación analítica de sistemas gravitatorios
	de varios cuerpos. El objetivo final es calcular las coordenadas
	para tirar un proyectil el 12 de junio del año 2010 a las 11:00hs,
	UTC-3 desde la órbita del planeta Neptuno para que el mismo impacte
	en la Tierra.
}

\palabraClave{}

\begin{titlepage}
\maketitle
\end{titlepage}
\tableofcontents
\newpage

	\begin{usection}{Introducción teorica}

		En la mecánica classica o Newtoniana, el problema de lo $n$
		cuerpos es el problema de predecir el movimiento de cuerpos
		celestes en mutua interacción gravitatoria para cualquier
		instante en el futuro o deducir su movimiento en cualquier
		instante del pasado.

		La acción gravitatoria entre los cuerpos depende de las
		posiciones relativas entre ellos, por lo que las ecuaciones de
		interacción gravitatoria quedan definidas en términos de
		ecuaciones diferenciales.

		El problema que surge al plantear el problema con $3 \leq n$ es
		que las ecuaciones el sistema quedan definidas en función de
		demasiadas variables como para aplicar los métodos de integración
		conocidos hoy en día para resolver las ecuaciones.

		Luego tenemos que encontrar otra forma de calcular las
		variables. En nuestro caso elegimos el método de simulación,
		el cuál introduce errores analíticos por discretizar el tiempo y
		de redondeo por trabajar con la aritmética finita de la
		computadora, pero que tiene la ventaja que el sistema a resolver
		es lineal, para lo cuál conocemos un método.

		Para minimizar estos errores implementamos distintos métodos de
		cálculo numérico de aproximación que validamos con sistemas
		familiares como el sistema solar, del cual sabemos por ejemplo
		que las órbitas son elípticas y bastante estables. Si dibujamos
		las órbitas simuladas podemos ver si se comportan de manera
		similar a lo esperado. Además, tenemos datos que se supone son
		bastante precisos descargados de la web oficial de la NASA para
		comparar.

	\end{usection}

	\begin{usection}{Desarrollo}

		En primer lugar el desarrollo consistio en implementar módulos
		para las operaciones con y entre Matrices y Vectores que
		sirviesen para resolver sistemas lineales. Esto implicaba
		también implementar el algoritmo de eliminación Gaussiana con
		pivoteo parcial para resolver el sistema lineal del segundo
		método de resolución. Los módulos fueron implementados en el
		lenguaje \texttt{C++} para garantizar una buena performance.

		Luego procedimos a implementar un entorno de simulación
		(\texttt{C++}) y un pequeño script para plotear y poder
		visualizar los resultados (\texttt{Python}). 

		Con todo el backend funcionando, procedimos a implementar
		gradualmente los distintos algoritmos de solución de sistemas
		lineales, intercalando la producción de cada uno con fases de
		validación que consistían en simular los sistemas propuestos
		en el enunciado, y cuyos resultados se pueden observar en la
		sección RESULTADOS.

		Validados los métodos de simulación, tuvimos que idear un
		algoritmo para calcular el vector de velocidad inicial de
		nuestro misil dirigido a la tierra, de tal manera que le pegase.
		La idea fue hacer una especie de búsqueda local, ya que
		suponíamos que de no colisionar con otro planeta en la
		trayectoria hasta la tierra, si pasabamos con una trayectoría
		mas cerca de la tierra que con otra, podíamos reducir la
		búsqueda de la solución a un espacio localizado cerca de la
		primera. Con un espacio o una trayectoria nos referimos a una
		velocidad inicial, la que en nuestro código esta determinada por
		dos ángulos de disparo. Uno sobre el eje $z$ y otro sobre el
		plano $xy$.

		para cada trayectoria inicial, definimos una grilla de $3x3$
		puntos, donde el punto central era ella misma, y los otros
		puntos son las rotaciones de la velocidad sobre los ejes
		anteriormente mencionados por un ángulo que se reduce a la
		mitad en cada iteración de la búsqueda, y luego disparámos
		misiles en todas las 9 direcciónes.
		Así, aunque en algunos casos asintóticamente,
		revisamos todo el espacio contenido en la grilla de la primera
		iteración, a la cuál le ponemos un ancho inicial grosero, de
		manera de incluír necesariamente a una solución.
		En la imágencontinuación se puede ver como evoluciona la grilla
		de la búsqueda en las sucesivas iteraciones.

		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.5]{img/grid.png}
			\caption{
				En la imagen vemos una representación gráfica de los
				sucesivos espacios de búsqueda local. el orden de las
				iteraciones es rojo $\rightarrow$ azul
				$\rightarrow$ verde.
			}
			\label{fig:grilla}
		\end{figure}		

		

	\end{usection}

	\begin{usection}{Resultados}

		%\input{resultados_ej1_m1.tex}
		%\input{resultados_ej1_m2.tex}
		%\input{resultados_ej2_m1.tex}
		%\input{resultados_ej2_m2.tex}

	\end{usection}
	
	\begin{usection}{Discusión}
		
	\end{usection}
	
	\begin{usection}{Conclusiones}
		
	\end{usection}
	
	\begin{usection}{Apéndices}
		\begin{usubsection}{Apéndice A: Enunciado}
			\input{enunciado.tex}
		\end{usubsection}
		
		\newpage
		\begin{usubsection}{Apéndice B: Codigos Fuente}
			
		\end{usubsection}
	\end{usection}
	
	\begin{usection}{Referencias}

	\begin{enumerate}
		\item \label{ref:label} \texttt{http://url} \\ Descripcion
	\end{enumerate}	
	
	\end{usection}

\end{document}

